//
//  Fio.cpp
//
//  Created by Jan Sten Adamek && Vojtech Micka on 2.10.13.
//  Copyright (c) 2013 All rights reserved.
//

#include "Fio.h"

#include <unistd.h>
#include <memory.h>

#include <iostream>

#pragma mark - Constructor

//////////////////////////////////////////////////////////////////////////////////////////
Fio::Fio(int fileDescriptor):
//////////////////////////////////////////////////////////////////////////////////////////
    _fileDescriptor(fileDescriptor),
    _ptr(_buffer + B_SIZE),
    _gcount(0),
    _fileFinish(false),
    _finish(false)
{
    _readToBuffer();
}

//////////////////////////////////////////////////////////////////////////////////////////
Fio::~Fio()
//////////////////////////////////////////////////////////////////////////////////////////
{
}

#pragma mark - Buffer handler

//////////////////////////////////////////////////////////////////////////////////////////
void Fio::_readToBuffer()
//////////////////////////////////////////////////////////////////////////////////////////
{
    
    ssize_t left = _buffer + B_SIZE - _ptr;

    if (left > 0) {
        memcpy(_buffer, _ptr, left);
    } else {
        left = 0;
    }
    
    _gcount = read(_fileDescriptor, _buffer + left, B_SIZE - left) + left;
    _ptr = _buffer;
    
    _buffer[_gcount] = 0;
    
    if (_gcount < B_SIZE) {
        _fileFinish = true;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
#pragma mark - String types
//////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////
char * Fio::nextWord()
//////////////////////////////////////////////////////////////////////////////////////////
{
    register char * out;
    register char ch;
    char * fBegin = _ptr;
    char * fEnd = _ptr;
    size_t size;
    
    do {
        ch = *fEnd;
        if (ch == 0) return 0;
        ++fEnd;
    } while (ch < 0x003A || ch > 0x007E);
    
    fBegin = fEnd;
    
    do {
        ch = *fEnd;
        ++fEnd;
    } while (ch >= 0x003A && ch <= 0x007E);
    
    size = fEnd - fBegin;
    
    out = new char[size];
    memcpy(out, fBegin, size);
    
    return out;
}

//////////////////////////////////////////////////////////////////////////////////////////
bool Fio::_parseLine(char *&ptr)
//////////////////////////////////////////////////////////////////////////////////////////
{
    register char ch;
    
    do {
        ch = *ptr;
        if (ch == 0) return false;
        ++ptr;
    } while (ch != '\n' && ch != 0);
    
    return true;
}

//////////////////////////////////////////////////////////////////////////////////////////
bool Fio::nextLine()
//////////////////////////////////////////////////////////////////////////////////////////
{
    register char *str;
    return nextLine(str);
}

//////////////////////////////////////////////////////////////////////////////////////////
bool Fio::nextLine(char *&line)
//////////////////////////////////////////////////////////////////////////////////////////
{
    char * fBegin = _ptr;
    char * fEnd = _ptr;
    size_t size;

    if (!_parseLine(fEnd)) {
        return false;
    }
    
    if (fEnd >= _buffer + _gcount + 1) {
        if (_fileFinish)
        {
            _finish = true;
            return false;
        }
        
        _readToBuffer();
        return nextLine(line);
    }
    
    size = fEnd - fBegin - 1;
        
    line = new char[size];
    memcpy(line, fBegin, size);
    line[size] = 0;

    _ptr = fEnd;
    
    return true;
}


//////////////////////////////////////////////////////////////////////////////////////////
#pragma mark - Numeric types
//////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////
long Fio::_parseLong(char *&ptr)
//////////////////////////////////////////////////////////////////////////////////////////
{
    register long n(0);
    register char ch;
    
    do {
        ch = *ptr;
        if (ch == 0) return 0;
        ++ptr;
    } while (ch < '0' || ch > '9');
    
    do {
        n = (ch & 0x0f) + n * 10;
        ch = *ptr;
        ++ptr;
    } while (ch >= '0' && ch <= '9');
    
    return n;
}

//////////////////////////////////////////////////////////////////////////////////////////
int Fio::nextInt()
//////////////////////////////////////////////////////////////////////////////////////////
{
    return (int) nextLong();
}

//////////////////////////////////////////////////////////////////////////////////////////
long Fio::nextLong()
//////////////////////////////////////////////////////////////////////////////////////////
{

    char * tPtr = _ptr;
    long num = _parseLong(tPtr);
    
    if (tPtr >= _buffer + _gcount) {
        if (_fileFinish)
        {
            _finish = true;
            return num;
        }
        
        _readToBuffer();
        tPtr = _ptr;
        num = _parseLong(tPtr);
    }
    
    _ptr = tPtr;
    
    return num;
}